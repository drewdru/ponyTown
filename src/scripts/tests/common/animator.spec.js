"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("../lib");
const chai_1 = require("chai");
const animator_1 = require("../../common/animator");
const sit = { name: 'sit', fps: 6, loop: true, frames: { length: 12 } };
const sit2 = { name: 'sit2', fps: 6, loop: true, frames: { length: 12 } };
const stand = { name: 'stand', fps: 6, loop: true, frames: { length: 6 } };
const run = { name: 'run', fps: 6, loop: true, frames: { length: 6 } };
describe('Animator', () => {
    let animator;
    beforeEach(() => {
        animator = animator_1.createAnimator();
    });
    after(() => {
        animator = undefined;
    });
    it('returns undefined animation by default', () => {
        chai_1.expect(animator_1.getAnimation(animator)).undefined;
    });
    it('returns 0 frame by default', () => {
        chai_1.expect(animator_1.getAnimationFrame(animator)).equal(0);
    });
    it('sets initial state', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator.state).equal(sitting);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit);
    });
    it('does not switch to new state immediately', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit);
        animator_1.setAnimatorState(animator, running);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit);
    });
    it('updates animation frame', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0);
        animator_1.updateAnimator(animator, 1);
        chai_1.expect(animator_1.getAnimationFrame(animator)).equal(6);
    });
    it('loops animation frame', () => {
        const state = animator_1.animatorState('sitting', sit);
        animator_1.setAnimatorState(animator, state);
        animator_1.updateAnimator(animator, 0);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator_1.getAnimationFrame(animator)).equal(6);
    });
    it('switches to next state immediately if exitAfter is set to 0', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running, { exitAfter: 0 });
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
    });
    it('switches to next state after half of the animation if exitAfter is set 0.5', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running, { exitAfter: 0.5 });
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit, 'after 0.1s');
        animator_1.updateAnimator(animator, 0.4);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit, 'after 0.5s');
        animator_1.updateAnimator(animator, 0.6);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run, 'after 1.1s');
    });
    it('switches to next state immediately if exitAfter is set 0.5 and time is already past 0.5', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running, { exitAfter: 0.5 });
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0);
        animator_1.updateAnimator(animator, 1.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
    });
    it('switches to middle of next state if enterTime is set to 0.5', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running, { exitAfter: 0, enterTime: 0.5 });
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
        chai_1.expect(animator_1.getAnimationFrame(animator)).equal(3);
    });
    it('keeps time of animation after switching if keepTime is set', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running, { exitAfter: 0, keepTime: true });
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0);
        animator_1.updateAnimator(animator, 0.5);
        chai_1.expect(animator_1.getAnimationFrame(animator)).equal(3, 'before');
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
        chai_1.expect(animator_1.getAnimationFrame(animator)).equal(3, 'after');
    });
    it('switches to state if set to switch from any', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running, { exitAfter: 0 });
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
    });
    it('does not use switch from any state as intermediate transition', () => {
        const lying = animator_1.animatorState('lying', sit);
        const sitting = animator_1.animatorState('sitting', sit);
        const standing = animator_1.animatorState('standing', sit);
        const flying = animator_1.animatorState('flying', sit);
        const hovering = animator_1.animatorState('hovering', sit);
        animator_1.animatorTransition(lying, sitting);
        animator_1.animatorTransition(sitting, standing);
        animator_1.animatorTransition(animator_1.anyState, flying);
        animator_1.animatorTransition(flying, hovering);
        animator_1.animatorTransition(standing, hovering);
        animator_1.setAnimatorState(animator, lying);
        animator_1.updateAnimator(animator, 0);
        animator_1.setAnimatorState(animator, hovering);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator.state).equal(sitting);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator.state).equal(standing);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator.state).equal(hovering);
    });
    it('does not use switch from any state is another transition is possible', () => {
        const lying = animator_1.animatorState('lying', sit);
        const standing = animator_1.animatorState('standing', sit);
        const hovering = animator_1.animatorState('hovering', sit);
        animator_1.animatorTransition(lying, standing);
        animator_1.animatorTransition(animator_1.anyState, hovering);
        animator_1.animatorTransition(standing, hovering);
        animator_1.setAnimatorState(animator, lying);
        animator_1.updateAnimator(animator, 0);
        animator_1.setAnimatorState(animator, hovering);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator.state).equal(standing);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator.state).equal(hovering);
    });
    it('uses switch from any state is another transition is possible but longer than 2 jumps', () => {
        const lying = animator_1.animatorState('lying', sit);
        const sitting = animator_1.animatorState('sitting', sit);
        const standing = animator_1.animatorState('standing', sit);
        const hovering = animator_1.animatorState('hovering', sit);
        animator_1.animatorTransition(lying, sitting);
        animator_1.animatorTransition(sitting, standing);
        animator_1.animatorTransition(animator_1.anyState, hovering);
        animator_1.animatorTransition(standing, hovering);
        animator_1.setAnimatorState(animator, lying);
        animator_1.updateAnimator(animator, 0);
        animator_1.setAnimatorState(animator, hovering);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator.state).equal(hovering);
    });
    it('does not switch to next state immediately if exitNow is not set', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit);
    });
    it('switches to next state when animation is finished', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
        chai_1.expect(animator_1.getAnimationFrame(animator)).equal(0);
    });
    it('does nothing if switching to already targeted state', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
    });
    it('does nothing if transition is no possible', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit);
    });
    it('switches through intermediate state', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const other = animator_1.animatorState('other', sit);
        const standing = animator_1.animatorState('standing', stand);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, standing);
        animator_1.animatorTransition(other, running);
        animator_1.animatorTransition(standing, running);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator_1.getAnimation(animator)).equal(stand);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
    });
    it('switches directly to target state if exitNow is set on both states', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const standing = animator_1.animatorState('standing', stand);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, standing, { exitAfter: 0 });
        animator_1.animatorTransition(standing, running, { exitAfter: 0 });
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
    });
    it('cancells switch to target state', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, running);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 3);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit);
    });
    it('handles loops in states', () => {
        const sitting = animator_1.animatorState('sitting', sit);
        const standing0 = animator_1.animatorState('standing0', sit);
        const standing1 = animator_1.animatorState('standing1', stand);
        const standing2 = animator_1.animatorState('standing2', stand);
        const running = animator_1.animatorState('running', run);
        animator_1.animatorTransition(sitting, standing0, { exitAfter: 0 });
        animator_1.animatorTransition(running, standing1, { exitAfter: 0 });
        animator_1.animatorTransition(running, standing2, { exitAfter: 0 });
        animator_1.animatorTransition(standing0, standing2, { exitAfter: 0 });
        animator_1.animatorTransition(standing1, running, { exitAfter: 0 });
        animator_1.animatorTransition(standing2, running, { exitAfter: 0 });
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        animator_1.setAnimatorState(animator, running);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator_1.getAnimation(animator)).equal(run);
    });
    it('returns correct animation variant', () => {
        const sitting = animator_1.animatorState('sitting', sit, { alt: sit2 });
        animator.variant = 'alt';
        animator_1.setAnimatorState(animator, sitting);
        animator_1.updateAnimator(animator, 0.1);
        chai_1.expect(animator_1.getAnimation(animator)).equal(sit2);
    });
    it('does not use shorter transition route if onlyDirectTo is set', () => {
        const standing = animator_1.animatorState('standing', run);
        const standingUp = animator_1.animatorState('standing-up', run);
        const sitting = animator_1.animatorState('sitting', run);
        const sittingUp = animator_1.animatorState('sitting-up', run);
        const lying = animator_1.animatorState('lying', run);
        const lyingToTrotting = animator_1.animatorState('lying-to-trotting', run);
        const trotting = animator_1.animatorState('trotting', run);
        animator_1.animatorTransition(lying, sittingUp);
        animator_1.animatorTransition(sittingUp, sitting);
        animator_1.animatorTransition(sitting, standingUp);
        animator_1.animatorTransition(standingUp, standing);
        animator_1.animatorTransition(lying, lyingToTrotting, { onlyDirectTo: trotting });
        animator_1.animatorTransition(lyingToTrotting, standing);
        animator_1.animatorTransition(lyingToTrotting, trotting);
        animator_1.setAnimatorState(animator, lying);
        animator_1.updateAnimator(animator, 0);
        animator_1.setAnimatorState(animator, standing);
        animator_1.updateAnimator(animator, 1.1);
        chai_1.expect(animator.state).equal(sittingUp);
        animator_1.updateAnimator(animator, 1.1);
        chai_1.expect(animator.state).equal(sitting);
        animator_1.updateAnimator(animator, 1.1);
        chai_1.expect(animator.state).equal(standingUp);
        animator_1.updateAnimator(animator, 1.1);
        chai_1.expect(animator.state).equal(standing);
    });
});
//# sourceMappingURL=animator.spec.js.map